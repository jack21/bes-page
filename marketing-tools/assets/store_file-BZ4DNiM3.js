import{a8 as It,a9 as mt,aa as Ct,ab as J,ac as W,a7 as ht,ad as U,ae as Lt,af as yt,ag as O,ah as Mt,ai as b,aj as C,ak as X,al as xt,am as v,an as Et,ao as ft,ap as lt,aq as bt,ar as _t,as as Ut,at as zt,au as Yt,av as Zt,aw as Bt,ax as kt,ay as Gt,az as Vt,aA as Wt,aB as dt,aC as gt,aD as Ht,aE as jt,aF as Xt,aG as vt,aH as Kt,aI as qt,aJ as Jt,aK as Qt,aL as $t,aM as te,aN as ee,aO as ae,aP as Dt,aQ as ne,aR as se,aS as re,aT as oe,aU as ie,aV as Rt,aW as ce,aX as Ee,aY as ut,aZ as fe,a_ as le,a$ as _e,a6 as de}from"./index-DQnVRHlo.js";function Q(a,e){return e&&e.trim().toLowerCase()=="cp437"?It(a):new TextDecoder(e).decode(a)}const K="File format is not recognized",ge="End of central directory not found",De="End of Zip64 central directory not found",Re="End of Zip64 central directory locator not found",ue="Central directory header not found",Te="Local file header not found",Ae="Zip64 extra field not found",we="File contains encrypted entry",Oe="Encryption method not supported",Tt="Compression method not supported",At="Split zip file",wt="utf-8",Ot="cp437",Fe=[[$t,b],[te,b],[ee,b],[ae,C]],he={[C]:{getValue:_,bytes:4},[b]:{getValue:V,bytes:8}};class pe{constructor(e,n={}){Object.assign(this,{reader:mt(e),options:n,config:Ct()})}async*getEntriesGenerator(e={}){const n=this;let{reader:t}=n;const{config:r}=n;if(await J(t),(t.size===W||!t.readUint8Array)&&(t=new ht(await new Response(t.readable).blob()),await J(t)),t.size<U)throw new Error(K);t.chunkSize=Lt(r);const o=await Ce(t,yt,t.size,U,C*16);if(!o){const p=await O(t,0,4),f=A(p);throw _(f)==Mt?new Error(At):new Error(ge)}const i=A(o);let c=_(i,12),s=_(i,16);const D=o.offset,R=T(i,20),l=D+U+R;let E=T(i,4);const L=t.lastDiskNumber||0;let h=T(i,6),S=T(i,8),u=0,I=0;if(s==b||c==b||S==C||h==C){const p=await O(t,o.offset-X,X),f=A(p);if(_(f,0)!=xt)throw new Error(De);s=V(f,8);let N=await O(t,s,v,-1),P=A(N);const m=o.offset-X-v;if(_(P,0)!=Et&&s!=m){const M=s;s=m,u=s-M,N=await O(t,s,v,-1),P=A(N)}if(_(P,0)!=Et)throw new Error(Re);E==C&&(E=_(P,16)),h==C&&(h=_(P,20)),S==C&&(S=V(P,32)),c==b&&(c=V(P,40)),s-=c}if(s>=t.size&&(u=t.size-s-c-U,s=t.size-c-U),L!=E)throw new Error(At);if(s<0)throw new Error(K);let d=0,w=await O(t,s,c,h),g=A(w);if(c){const p=o.offset-c;if(_(g,d)!=ft&&s!=p){const f=s;s=p,u+=s-f,w=await O(t,s,c,h),g=A(w)}}const y=o.offset-s-(t.lastDiskOffset||0);if(c!=y&&y>=0&&(c=y,w=await O(t,s,c,h),g=A(w)),s<0||s>=t.size)throw new Error(K);const Y=F(n,e,"filenameEncoding"),H=F(n,e,"commentEncoding");for(let p=0;p<S;p++){const f=new Ne(t,r,n.options);if(_(g,d)!=ft)throw new Error(ue);pt(f,g,d+6);const N=!!f.bitFlag.languageEncodingFlag,P=d+46,m=P+f.filenameLength,M=m+f.extraFieldLength,G=T(g,d+4),Z=(G&0)==0,x=w.subarray(P,m),$=T(g,d+32),tt=M+$,et=w.subarray(M,tt),at=N,nt=N,st=Z&&(z(g,d+38)&lt)==lt,rt=_(g,d+42)+u;Object.assign(f,{versionMadeBy:G,msDosCompatible:Z,compressedSize:0,uncompressedSize:0,commentLength:$,directory:st,offset:rt,diskNumberStart:T(g,d+34),internalFileAttribute:T(g,d+36),externalFileAttribute:_(g,d+38),rawFilename:x,filenameUTF8:at,commentUTF8:nt,rawExtraField:w.subarray(m,M)});const[ot,Pt]=await Promise.all([Q(x,at?wt:Y||Ot),Q(et,nt?wt:H||Ot)]);Object.assign(f,{rawComment:et,filename:ot,comment:Pt,directory:st||ot.endsWith(bt)}),I=Math.max(rt,I),await Nt(f,f,g,d+6);const j=new _t(f);j.getData=(ct,St)=>f.getData(ct,j,St),d=tt;const{onprogress:it}=e;if(it)try{await it(p+1,S,new _t(f))}catch{}yield j}const B=F(n,e,"extractPrependedData"),k=F(n,e,"extractAppendedData");return B&&(n.prependedData=I>0?await O(t,0,I):new Uint8Array),n.comment=R?await O(t,D+U,R):new Uint8Array,k&&(n.appendedData=l<t.size?await O(t,l,t.size-l):new Uint8Array),!0}async getEntries(e={}){const n=[];for await(const t of this.getEntriesGenerator(e))n.push(t);return n}async close(){}}class Ne{constructor(e,n,t){Object.assign(this,{reader:e,config:n,options:t})}async getData(e,n,t={}){const r=this,{reader:o,offset:i,diskNumberStart:c,extraFieldAES:s,compressionMethod:D,config:R,bitFlag:l,signature:E,rawLastModDate:L,uncompressedSize:h,compressedSize:S}=r,u=n.localDirectory={},I=await O(o,i,30,c),d=A(I);let w=F(r,t,"password"),g=F(r,t,"rawPassword");if(w=w&&w.length&&w,g=g&&g.length&&g,s&&s.originalCompressionMethod!=Ut)throw new Error(Tt);if(D!=zt&&D!=Yt)throw new Error(Tt);if(_(d,0)!=Zt)throw new Error(Te);pt(u,d,4),u.rawExtraField=u.extraFieldLength?await O(o,i+30+u.filenameLength,u.extraFieldLength,c):new Uint8Array,await Nt(r,u,d,4,!0),Object.assign(n,{lastAccessDate:u.lastAccessDate,creationDate:u.creationDate});const y=r.encrypted&&u.encrypted,Y=y&&!s;if(y){if(!Y&&s.strength===W)throw new Error(Oe);if(!w&&!g)throw new Error(we)}const H=i+30+u.filenameLength+u.extraFieldLength,B=S,k=o.readable;Object.assign(k,{diskNumberStart:c,offset:H,size:B});const p=F(r,t,"signal"),f=F(r,t,"checkPasswordOnly");f&&(e=new WritableStream),e=Bt(e),await J(e,h);const{writable:N}=e,{onstart:P,onprogress:m,onend:M}=t,G={options:{codecType:kt,password:w,rawPassword:g,zipCrypto:Y,encryptionStrength:s&&s.strength,signed:F(r,t,"checkSignature"),passwordVerification:Y&&(l.dataDescriptor?L>>>8&255:E>>>24&255),signature:E,compressed:D!=0,encrypted:y,useWebWorkers:F(r,t,"useWebWorkers"),useCompressionStream:F(r,t,"useCompressionStream"),transferStreams:F(r,t,"transferStreams"),checkPasswordOnly:f},config:R,streamOptions:{signal:p,size:B,onstart:P,onprogress:m,onend:M}};let Z=0;try{({outputSize:Z}=await Gt({readable:k,writable:N},G))}catch(x){if(!f||x.message!=Vt)throw x}finally{const x=F(r,t,"preventClose");N.size+=Z,!x&&!N.locked&&await N.getWriter().close()}return f?W:e.getData?e.getData():N}}function pt(a,e,n){const t=a.rawBitFlag=T(e,n+2),r=(t&Dt)==Dt,o=_(e,n+6);Object.assign(a,{encrypted:r,version:T(e,n),bitFlag:{level:(t&Wt)>>1,dataDescriptor:(t&dt)==dt,languageEncodingFlag:(t&gt)==gt},rawLastModDate:o,lastModDate:Le(o),filenameLength:T(e,n+22),extraFieldLength:T(e,n+24)})}async function Nt(a,e,n,t,r){const{rawExtraField:o}=e,i=e.extraField=new Map,c=A(new Uint8Array(o));let s=0;try{for(;s<o.length;){const I=T(c,s),d=T(c,s+2);i.set(I,{type:I,data:o.slice(s+4,s+4+d)}),s+=4+d}}catch{}const D=T(n,t+4);Object.assign(e,{signature:_(n,t+10),uncompressedSize:_(n,t+18),compressedSize:_(n,t+14)});const R=i.get(Ht);R&&(Pe(R,e),e.extraFieldZip64=R);const l=i.get(jt);l&&(await Ft(l,se,ne,e,a),e.extraFieldUnicodePath=l);const E=i.get(Xt);E&&(await Ft(E,oe,re,e,a),e.extraFieldUnicodeComment=E);const L=i.get(vt);L?(Se(L,e,D),e.extraFieldAES=L):e.compressionMethod=D;const h=i.get(Kt);h&&(Ie(h,e),e.extraFieldNTFS=h);const S=i.get(qt);S&&(me(S,e,r),e.extraFieldExtendedTimestamp=S);const u=i.get(Jt);u&&(e.extraFieldUSDZ=u)}function Pe(a,e){e.zip64=!0;const n=A(a.data),t=Fe.filter(([r,o])=>e[r]==o);for(let r=0,o=0;r<t.length;r++){const[i,c]=t[r];if(e[i]==c){const s=he[c];e[i]=a[i]=s.getValue(n,o),o+=s.bytes}else if(a[i])throw new Error(Ae)}}async function Ft(a,e,n,t,r){const o=A(a.data),i=new ie;i.append(r[n]);const c=A(new Uint8Array(4));c.setUint32(0,i.get(),!0);const s=_(o,1);Object.assign(a,{version:z(o,0),[e]:Q(a.data.subarray(5)),valid:!r.bitFlag.languageEncodingFlag&&s==_(c,0)}),a.valid&&(t[e]=a[e],t[e+"UTF8"]=!0)}function Se(a,e,n){const t=A(a.data),r=z(t,4);Object.assign(a,{vendorVersion:z(t,0),vendorId:z(t,2),strength:r,originalCompressionMethod:n,compressionMethod:T(t,5)}),e.compressionMethod=a.compressionMethod}function Ie(a,e){const n=A(a.data);let t=4,r;try{for(;t<a.data.length&&!r;){const o=T(n,t),i=T(n,t+2);o==Qt&&(r=a.data.slice(t+4,t+4+i)),t+=4+i}}catch{}try{if(r&&r.length==24){const o=A(r),i=o.getBigUint64(0,!0),c=o.getBigUint64(8,!0),s=o.getBigUint64(16,!0);Object.assign(a,{rawLastModDate:i,rawLastAccessDate:c,rawCreationDate:s});const D=q(i),R=q(c),l=q(s),E={lastModDate:D,lastAccessDate:R,creationDate:l};Object.assign(a,E),Object.assign(e,E)}}catch{}}function me(a,e,n){const t=A(a.data),r=z(t,0),o=[],i=[];n?((r&1)==1&&(o.push(Rt),i.push(ut)),(r&2)==2&&(o.push(ce),i.push(fe)),(r&4)==4&&(o.push(Ee),i.push(le))):a.data.length>=5&&(o.push(Rt),i.push(ut));let c=1;o.forEach((s,D)=>{if(a.data.length>=c+4){const R=_(t,c);e[s]=a[s]=new Date(R*1e3);const l=i[D];a[l]=R}c+=4})}async function Ce(a,e,n,t,r){const o=new Uint8Array(4),i=A(o);ye(i,0,e);const c=t+r;return await s(t)||await s(Math.min(c,n));async function s(D){const R=n-D,l=await O(a,R,D);for(let E=l.length-t;E>=0;E--)if(l[E]==o[0]&&l[E+1]==o[1]&&l[E+2]==o[2]&&l[E+3]==o[3])return{offset:R+E,buffer:l.slice(E,E+t).buffer}}}function F(a,e,n){return e[n]===W?a.options[n]:e[n]}function Le(a){const e=(a&4294901760)>>16,n=a&65535;try{return new Date(1980+((e&65024)>>9),((e&480)>>5)-1,e&31,(n&63488)>>11,(n&2016)>>5,(n&31)*2,0)}catch{}}function q(a){return new Date(Number(a/BigInt(1e4)-BigInt(116444736e5)))}function z(a,e){return a.getUint8(e)}function T(a,e){return a.getUint16(e,!0)}function _(a,e){return a.getUint32(e,!0)}function V(a,e){return Number(a.getBigUint64(e,!0))}function ye(a,e,n){a.setUint32(e,n,!0)}function A(a){return new DataView(a.buffer)}const xe=_e("file",{state:()=>({}),getters:{},actions:{decodeDSCText(a){const e=a.split(`
`).splice(1),n=new Map;let t=0;for(let r of e){if(r=r.trim(),r.length===0)continue;const[o,i]=r.split(",");n.set(i.slice(1,i.length-1),o.slice(1,o.length-1)),t++}return{dataMap:n,lineCount:t}},async decodeDSCFile(a,e){let n=0;const t=new Map;let r;try{r=new pe(new ht(a),{password:e});const o=await r.getEntries();for(const i of o)if(i&&!i.directory&&typeof i.getData=="function"){const s=await(await i.getData(new de)).text(),D=this.decodeDSCText(s);n+=D.lineCount;for(const[R,l]of D.dataMap)t.set(R,l)}}finally{r&&await r.close()}return{dataMap:t,lineCount:n}}}});export{xe as u};
